# cpuex2-assembler

```
Usage: assembler [OPTIONS]

Options:
  -f, --file <FILE>    Name of the input file [default: main.asm]
  -s, --style <STYLE>  Style of output: '2', '16', 'ram', or 'bin' [default: ram]
  -h, --help           Print help
  -V, --version        Print version
```

## 詳細
Rust により実装した、2班のアセンブラです。

### アセンブリコードの仕様について
アセンブリコードとして受け付けるファイル形式は基本的には RISC-V 32bit に準拠していますが、2班のISAに沿っていくつかの命令が追加または削除されています。
コメントアウトは `#` または `;` を使用できます。

### 動作環境
Cargo を用いてビルド・実行をすることが前提になっています。WSL2 で動作確認をしています。なお用いた Rust のバージョンおよび Cargo のバージョンは
```sh
$ rustc --version
rustc 1.70.0 (90c541806 2023-05-31)
$ cargo --version
cargo 1.70.0 (ec8a8a0ca 2023-04-25)
```
です。

### 実行方法
実行時のオプションの説明は次のようになります(`make help` でも確認できます)。
```
Usage: assembler [OPTIONS]

Options:
  -f, --file <FILE>    Name of the input file [default: main.asm]
  -s, --style <STYLE>  Style of output: '2', '16', 'ram', or 'bin' [default: ram]
  -h, --help           Print help
  -V, --version        Print version
```
`--file` オプションで入力ファイル名を指定できます。また`--style` オプションで出力形式を指定できます。`2` で2進数、 `16` で16進数、`ram` でコアでハードコードするための形式、`bin` でバイナリになります。なお出力ファイルは入力ファイルの拡張子を変更したものになります。
例えば、次のように実行すると、`minrt.s` をアセンブルしてバイナリ形式でアセンブルの結果 `minrt.bin` を出力します。
```sh
$ cargo run -- --file minrt.s --style bin
```

### 出力されるファイルについて
以下では、`minrt.s` をアセンブルした結果のファイルについて説明します。
- `minrt.2` は2進数で出力されたファイルです。
- `minrt.16` は16進数で出力されたファイルです。
- `minrt.bin` はバイナリ形式で出力されたファイルです。
- `minrt.ram` はコアでハードコードするための形式で出力されたファイルです。
- `minrt.data` は data セクションの内容を出力したファイルです。各行に、アドレスとそのアドレスに格納されるべきデータが出力されます。デバッグ用です。
- `minrt.pc.asm` は、元のアセンブリコードの各行に、コメントとしてPCの値を出力したファイルです。ただし、後ほど述べるアセンブル時に自動で追加されるいくつかの命令が付け加えられた後のコードになっています。デバッグ用です。
- `minrt.lmap` は、アセンブリコードの text セクションにある各ラベルの名前とそのアドレスを出力したファイルです。命令レベルのシミュレータに対しこれを入力として与えることができます。

### 各ソースファイルの説明
`src` ディレクトリにある各ファイルの説明です。
- `main.rs` はエントリーポイントです。コマンドライン引数をパースして、`assemble` 関数を呼び出します。
- `assembler.rs` はアセンブルを行うための関数を定義しています。どのような手順を踏んでアセンブルを行うかについては次の節で説明します。
- `constants.rs` は定数を定義しています。

### アセンブルの手順
アセンブルの手順を、大まかに説明します。
1. data セクションの内容を読み込み、アドレスとデータの対応を決定します。
2. 1の結果を元に、data セクションを初期化するための命令を先頭に追加します。また data セクションの長さを元に、ヒープポインタを初期化するための命令を先頭に追加します。data セクションはメモリの先頭から始まりますが、data セクションの末尾からヒープが始まるようにします。
3. 続いて text セクションの各ラベルのアドレスを決定します。疑似命令がいくつの命令に展開されるか(1または2)、また分岐命令がいくつかの命令に展開されるかどうか(分岐命令においてはある程度大きなジャンプはできないため、さらにジャンプを挟むなどの工夫が必要になる)といったことを調べる必要があります。このアセンブラでそれをどのように行っているかを説明します。最初に、複数の命令に展開される可能性がある命令をすべてそのように展開するものとみなした上で、暫定的な各ラベルのアドレスを定めます。次にそれに基づいて各命令が何命令に展開されるかを調べ、再び各ラベルのアドレスを定めます。これを変化が生じなくなるまで繰り返すことで、最終的な各ラベルのアドレスを決定します。入力ファイルによってはこのループにかなりの時間がかかる可能性がありますが、`minrt.ml` をコンパイルした結果に対しては数秒程度で完了するので、問題ないと判断しました。 
4. 3まででアドレスの決定が済んだので、後はISAに基づき各命令を(疑似命令については展開をしながら)バイナリ形式などに変換していきます。すべての命令が変換できたらアセンブル完了です。
